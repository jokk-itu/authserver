import{S as se,i as oe,s as ae,x as tt,a as _,y as et,c as $,z as rt,b as w,f as st,t as ot,A as at,h as r,k as o,q as p,l as a,m as n,r as u,E as t,C as _t,n as C}from"../../../chunks/index-86aa8d89.js";import{P as ne}from"../../../chunks/PageTitle-cc378c43.js";import{S as ut}from"../../../chunks/Section-4061cb73.js";function ie(b){let s,c;return{c(){s=o("p"),c=p(`Discovery is used for relying parties to fetch information
    about the authorization server from a well known uri.
    Information includes endpoints and supported features.`)},l(i){s=a(i,"P",{});var f=n(s);c=u(f,`Discovery is used for relying parties to fetch information
    about the authorization server from a well known uri.
    Information includes endpoints and supported features.`),f.forEach(r)},m(i,f){w(i,s,f),t(s,c)},p:_t,d(i){i&&r(s)}}}function le(b){let s,c,i,f,v,E,d,g,T,D,e,l;return{c(){s=o("ul"),c=o("li"),i=o("a"),f=p("JWA"),v=_(),E=o("li"),d=o("a"),g=p("OAuth Discovery"),T=_(),D=o("li"),e=o("a"),l=p("OIDC Discovery"),this.h()},l(k){s=a(k,"UL",{});var m=n(s);c=a(m,"LI",{});var W=n(c);i=a(W,"A",{class:!0,href:!0});var U=n(i);f=u(U,"JWA"),U.forEach(r),W.forEach(r),v=$(m),E=a(m,"LI",{});var L=n(E);d=a(L,"A",{href:!0});var x=n(d);g=u(x,"OAuth Discovery"),x.forEach(r),L.forEach(r),T=$(m),D=a(m,"LI",{});var O=n(D);e=a(O,"A",{href:!0});var z=n(e);l=u(z,"OIDC Discovery"),z.forEach(r),O.forEach(r),m.forEach(r),this.h()},h(){C(i,"class","ref-link"),C(i,"href","https://datatracker.ietf.org/doc/html/rfc7518"),C(d,"href","https://datatracker.ietf.org/doc/html/rfc8414"),C(e,"href","https://openid.net/specs/openid-connect-discovery-1_0.html")},m(k,m){w(k,s,m),t(s,c),t(c,i),t(i,f),t(s,v),t(s,E),t(E,d),t(d,g),t(s,T),t(s,D),t(D,e),t(e,l)},p:_t,d(k){k&&r(s)}}}function fe(b){let s,c;return{c(){s=o("p"),c=p(`An endpoint used to provide metadata about the authorization server. It exposes data such as endpoints,
    supported grants and algorithms used for signing tokens.`)},l(i){s=a(i,"P",{});var f=n(s);c=u(f,`An endpoint used to provide metadata about the authorization server. It exposes data such as endpoints,
    supported grants and algorithms used for signing tokens.`),f.forEach(r)},m(i,f){w(i,s,f),t(s,c)},p:_t,d(i){i&&r(s)}}}function de(b){let s,c,i,f,v,E,d,g,T=`
{
    "kty": "RSA",
    "use": "sig",
    "kid": 1,
    "alg": "RS256",
    "n": "MODULUS VALUE",
    "e": "AQAB"
}
`,D,e,l,k,m,W,U,L,x,O,z,y,K,H,$t,mt,M,vt,Et,R,q,Tt,yt,Q,gt,Dt,I,V,kt,wt,Y,Jt,Wt,S,j,At,bt,F,Ut,xt,P,G,Kt,Rt,N,It,St,B,X,Pt,Bt,Z,Lt;return{c(){s=o("p"),c=p(`The array always returns three keys.
    The first is the newest key which has expired.
    This is important for resources which have received a JWT which is signed by an expired key.
    The second JWK is the currently used for signing JWT.
    The third JWK is the next in line, when the current JWK expires.`),i=_(),f=o("p"),v=p("The format of a JWK is as follows:"),E=_(),d=o("pre"),g=o("code"),D=p(T),e=_(),l=o("table"),k=o("thead"),m=o("tr"),W=o("th"),U=p("Property"),L=_(),x=o("th"),O=p("Description"),z=_(),y=o("tbody"),K=o("tr"),H=o("td"),$t=p("kty"),mt=_(),M=o("td"),vt=p("Used to identify the type of the JWK"),Et=_(),R=o("tr"),q=o("td"),Tt=p("use"),yt=_(),Q=o("td"),gt=p("Used to identity the usage of the JWK"),Dt=_(),I=o("tr"),V=o("td"),kt=p("kid"),wt=_(),Y=o("td"),Jt=p("Used as an identifier for the JWK"),Wt=_(),S=o("tr"),j=o("td"),At=p("alg"),bt=_(),F=o("td"),Ut=p("Used to identify the used algorithm for signing JWT"),xt=_(),P=o("tr"),G=o("td"),Kt=p("n"),Rt=_(),N=o("td"),It=p("Modulus of the RSA public key. It is Base64 Url encoded"),St=_(),B=o("tr"),X=o("td"),Pt=p("e"),Bt=_(),Z=o("td"),Lt=p("Exponent of the RSA public key. it is Base64 Url encoded"),this.h()},l(h){s=a(h,"P",{});var A=n(s);c=u(A,`The array always returns three keys.
    The first is the newest key which has expired.
    This is important for resources which have received a JWT which is signed by an expired key.
    The second JWK is the currently used for signing JWT.
    The third JWK is the next in line, when the current JWK expires.`),A.forEach(r),i=$(h),f=a(h,"P",{});var Ot=n(f);v=u(Ot,"The format of a JWK is as follows:"),Ot.forEach(r),E=$(h),d=a(h,"PRE",{class:!0});var zt=n(d);g=a(zt,"CODE",{});var Ct=n(g);D=u(Ct,T),Ct.forEach(r),zt.forEach(r),e=$(h),l=a(h,"TABLE",{class:!0});var nt=n(l);k=a(nt,"THEAD",{});var Ht=n(k);m=a(Ht,"TR",{});var it=n(m);W=a(it,"TH",{});var Mt=n(W);U=u(Mt,"Property"),Mt.forEach(r),L=$(it),x=a(it,"TH",{});var qt=n(x);O=u(qt,"Description"),qt.forEach(r),it.forEach(r),Ht.forEach(r),z=$(nt),y=a(nt,"TBODY",{});var J=n(y);K=a(J,"TR",{});var lt=n(K);H=a(lt,"TD",{});var Qt=n(H);$t=u(Qt,"kty"),Qt.forEach(r),mt=$(lt),M=a(lt,"TD",{});var Vt=n(M);vt=u(Vt,"Used to identify the type of the JWK"),Vt.forEach(r),lt.forEach(r),Et=$(J),R=a(J,"TR",{});var ft=n(R);q=a(ft,"TD",{});var Yt=n(q);Tt=u(Yt,"use"),Yt.forEach(r),yt=$(ft),Q=a(ft,"TD",{});var jt=n(Q);gt=u(jt,"Used to identity the usage of the JWK"),jt.forEach(r),ft.forEach(r),Dt=$(J),I=a(J,"TR",{});var dt=n(I);V=a(dt,"TD",{});var Ft=n(V);kt=u(Ft,"kid"),Ft.forEach(r),wt=$(dt),Y=a(dt,"TD",{});var Gt=n(Y);Jt=u(Gt,"Used as an identifier for the JWK"),Gt.forEach(r),dt.forEach(r),Wt=$(J),S=a(J,"TR",{});var ht=n(S);j=a(ht,"TD",{});var Nt=n(j);At=u(Nt,"alg"),Nt.forEach(r),bt=$(ht),F=a(ht,"TD",{});var Xt=n(F);Ut=u(Xt,"Used to identify the used algorithm for signing JWT"),Xt.forEach(r),ht.forEach(r),xt=$(J),P=a(J,"TR",{});var ct=n(P);G=a(ct,"TD",{});var Zt=n(G);Kt=u(Zt,"n"),Zt.forEach(r),Rt=$(ct),N=a(ct,"TD",{});var te=n(N);It=u(te,"Modulus of the RSA public key. It is Base64 Url encoded"),te.forEach(r),ct.forEach(r),St=$(J),B=a(J,"TR",{});var pt=n(B);X=a(pt,"TD",{});var ee=n(X);Pt=u(ee,"e"),ee.forEach(r),Bt=$(pt),Z=a(pt,"TD",{});var re=n(Z);Lt=u(re,"Exponent of the RSA public key. it is Base64 Url encoded"),re.forEach(r),pt.forEach(r),J.forEach(r),nt.forEach(r),this.h()},h(){C(d,"class","pb-4"),C(l,"class","table-auto")},m(h,A){w(h,s,A),t(s,c),w(h,i,A),w(h,f,A),t(f,v),w(h,E,A),w(h,d,A),t(d,g),t(g,D),w(h,e,A),w(h,l,A),t(l,k),t(k,m),t(m,W),t(W,U),t(m,L),t(m,x),t(x,O),t(l,z),t(l,y),t(y,K),t(K,H),t(H,$t),t(K,mt),t(K,M),t(M,vt),t(y,Et),t(y,R),t(R,q),t(q,Tt),t(R,yt),t(R,Q),t(Q,gt),t(y,Dt),t(y,I),t(I,V),t(V,kt),t(I,wt),t(I,Y),t(Y,Jt),t(y,Wt),t(y,S),t(S,j),t(j,At),t(S,bt),t(S,F),t(F,Ut),t(y,xt),t(y,P),t(P,G),t(G,Kt),t(P,Rt),t(P,N),t(N,It),t(y,St),t(y,B),t(B,X),t(X,Pt),t(B,Bt),t(B,Z),t(Z,Lt)},p:_t,d(h){h&&r(s),h&&r(i),h&&r(f),h&&r(E),h&&r(d),h&&r(e),h&&r(l)}}}function he(b){let s,c,i,f,v,E,d,g,T,D;return s=new ne({props:{title:"Discovery Endpoint"}}),i=new ut({props:{title:"Introduction",$$slots:{default:[ie]},$$scope:{ctx:b}}}),v=new ut({props:{title:"Specifications",$$slots:{default:[le]},$$scope:{ctx:b}}}),d=new ut({props:{title:"Discovery",$$slots:{default:[fe]},$$scope:{ctx:b}}}),T=new ut({props:{title:"JWK",$$slots:{default:[de]},$$scope:{ctx:b}}}),{c(){tt(s.$$.fragment),c=_(),tt(i.$$.fragment),f=_(),tt(v.$$.fragment),E=_(),tt(d.$$.fragment),g=_(),tt(T.$$.fragment)},l(e){et(s.$$.fragment,e),c=$(e),et(i.$$.fragment,e),f=$(e),et(v.$$.fragment,e),E=$(e),et(d.$$.fragment,e),g=$(e),et(T.$$.fragment,e)},m(e,l){rt(s,e,l),w(e,c,l),rt(i,e,l),w(e,f,l),rt(v,e,l),w(e,E,l),rt(d,e,l),w(e,g,l),rt(T,e,l),D=!0},p(e,[l]){const k={};l&1&&(k.$$scope={dirty:l,ctx:e}),i.$set(k);const m={};l&1&&(m.$$scope={dirty:l,ctx:e}),v.$set(m);const W={};l&1&&(W.$$scope={dirty:l,ctx:e}),d.$set(W);const U={};l&1&&(U.$$scope={dirty:l,ctx:e}),T.$set(U)},i(e){D||(st(s.$$.fragment,e),st(i.$$.fragment,e),st(v.$$.fragment,e),st(d.$$.fragment,e),st(T.$$.fragment,e),D=!0)},o(e){ot(s.$$.fragment,e),ot(i.$$.fragment,e),ot(v.$$.fragment,e),ot(d.$$.fragment,e),ot(T.$$.fragment,e),D=!1},d(e){at(s,e),e&&r(c),at(i,e),e&&r(f),at(v,e),e&&r(E),at(d,e),e&&r(g),at(T,e)}}}class _e extends se{constructor(s){super(),oe(this,s,null,he,ae,{})}}export{_e as default};
